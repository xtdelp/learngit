# Git技术学习

## 1.Git是什么？

Git实际上就是一个分布式档案监管系统，而并不是一个严格意义上的存储系统，一般来说它只能监管文本数据，如果文本数据以二进制形式或者产生编码错误的情况的，Git都无法进行识别。Git的出现就是为了使得项目历史修改变得有迹可循且可溯源。分布式意味着项目内容可以分布在多处，满足了多人协同工作的需求。

Git的下载：`https://git-scm.com/downloads`

下载配置完毕以后我们就可以在windows的console当中使用Git。

## 2.Git的简单使用

既然Git是一个档案库，我们就需要一个地址来装载这些档案：

```
cd /gitpath
git init
```

就可以设置git到当前目录下，随后我们还可以进行用户名以及邮箱的配置

```
git config --global user.name "lambgit"
git config --global user.email "ab1099127537@gmail.com"
```

这样操作完成以后我们就可以使用git仓库啦。

**往git当中添加档案**：`git add profile.txt /git commit -m "this is description"`

别问我为什么提交数据要俩条命令才能完成，还不是为了如果有多个提交内容可以一次一起进库，还可以方便管理。被add但是没有commit的文件会被放入到暂存区（stage）当中。要注意的是提交到暂存区以后即使再修改，本次的commit也不会记录新的修改，而只会提交被提交到缓存区时刻的修改状态，因此如果想要更新内容，还得再add和commit一次。

通过commit存入以后，git就可以监管这些档案的状态啦。

**状态监管**：`git status`可以查看那些文档被修改过但是还没有提交上来，被修改过的文档会被标记为红，而`git diff`就可以看到具体修改了那些文本内容。

**时空穿越**：Git牛逼就牛逼在它可以帮助我们在不同版本之间的文档来回穿梭，穿梭的时间节点就是我们commit的时间节点，不仅仅是档案库中的某一个特定文档的历史穿梭还是档案库当中所有文档的历史信息的穿梭，`git reset --hard sha_code`有了这个功能我们就能穿越回侏罗纪公园，整个档案还是一坨shit的时候。git实现这项功能依赖于其内部HEAD指针，并构建了有向无环树的数据结构，在穿越时git就将指针指向不同版本的内存地址，然后更新文件，当然git能这样做的基础还是在git的文件夹下生成了一个隐藏的`.git`这个文档当中就记录了这些历史信息。

其中值得注意的是每次修改git都给了一个对应的sha编码的id值，这里的sha指的就是常见的哈希算法sha_1，目的也是为了避免id命名重复的问题。

**获取档案**：现在我们已经知道了怎么提交文件，但我们要怎么拿一个档案下来了，`git checkout --`命令可以帮助我们完成档案的本地同步，这种同步是同步当前最新版本的档案，如果最新的修改在暂存区，那就是回到暂存区的修改状态。

**删除文档**：如果有些文档我们不想要了，诚然我们可以用window的console命令`rm file_name`来快速删除一个文件，但是在git看来这也是一种修改，因此如果想要提交这种修改我们就需要`git rm file_name`+`git commit -m`来提交本次修改。

## 3.Branch的使用

**branch的基本概念**：branch就像是一个平行宇宙，假设我们在某一个时间节点创建了某一个分支branch 

`git checkout -b branch_name`-b表示创建并切换到该新分支，相当于git branch branch_name + git switch branch_name两个操作二合一。

那么从这个时间节点开始在branch上的任何操作与master上的任何操作都不会相互干扰，背后的原理就是branch相当于一个全新的指向某个时间节点的指针，而HEAD通过改变自身指向branch或者master来间接指向节点。

**合并**：当`git merge master`时主干就会将内容更新至与分支一致。

要注意的是只要我们进行节点切换，我们档案库当中的数据都会进行相应的变化。

那么问题来了，当主干的内容和分支同时进行推进时，git会如何进行合并呢？事实上如果出现branch与master上的内容不能完美融合，git就会跳出报告conflict，需要我们手动将出现问题的文档进行更新并提交，而这种方式实际上相当于手动的把分支上的代码复制过来了，但本质还是一样的。